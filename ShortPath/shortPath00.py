'''
최단경로 문제
- 다익스트라 알고리즘 이용(BFS 너비 우선 탐색)
- "우선순위 큐(최소 힙 방식)"를 이용하여, 시간 복잡도 O(nlogn)
- 여기서 이동 경로가 양수라 하면 Dikjstra 알고리즘이고 음수를 포함한다면 Bellman-ford 알고리즘
'''

'''
* 다익스트라 알고리즘

1. 출발 노드를 설정
2. 최단 거리 테이블을 초기화(그러므로 최단 거리를 기록할 테이블을 정의해야 함)
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택(방문하지 않은 노드를 체크해야 하므로 이를 위한 테이블을 정의해야 함)
4. 해당 노드를 거쳐 다른 노드로 가는 간선 비용을 계산하여 최단 거리 테이블을 업데이트
5. 위 과정에서 3, 4번을 반복

[풀이]
- 2가지 빈 리스트 필요(최단거리 기록 테이블 리스트, 방문 노드 체크 리스트)
- 두 리스트 모두 노드가 N개 있다고 할 때, N+1크기로 정의하기
- 최단거리 기록 테이블은 큰 수로 초기화(1억 1e8)
- 방문 체크 리스트는 False(방문하지 않음)으로 초기

[자세히]
1. 사직노드를 1번이라 하면 노드번호 1번의 거리는 0으로 업뎃
2. 시작노드 1번과 인접한 노드(2, 3, 4)에 접근 후 거리 업뎃
3. 시작노드였던 1번 노드를 방문 처리 하고, 1번 노드의 인접노드들(2, 3, 4) 중 방문하지 않은 노드(2, 3, 4)중 시작노드인
1번 노드와 가장 최단거리인 4번 노드를 다음에 탐색할 노드(4번!)로 선택! min( , )
4. 다음 탐색할 노드인 4번 노드에 인접한 노드 찾기(3, 5)
5. 3번 노드는 이전에 1번 노드와 인접한 노드이므로 min(1번노드와 거리, 1과 4의 거리+ 4와 3의 거리) 으로 업뎃
6. 5번 노드는 min(기본값인 무한대, 1과 4의 거리 + 4와 5의 거리) 로 업뎃
7. 반복
8. 가장 마지막으로 갱신된 거리 테이블을 기준으로 방문하지 않은 노드들 중 가장 거리가 작은
즉, 원소값이 가장 작은 인덱스 번호를 다음으로 탐색할 노드로 선정
9. 방문하지 않은 노드 중 갱신한 테이블 기준으로 시작노드와 가장 최단거리인 노드를 탐색한다.

[핵심]
- 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정 반복
- 각 단계마다 탐색노드로 한 번 선택된 노드는 최단거리가 갱신되고 난 후 재갱신 되지 않는 것을 확인 할 수 있다.
'''

'''
* 플로이드 와샬 알고리즘
최단거리를 구하는 알고리즘이지만, BFS가 한 정점에서부터 모든 정점으로의 최단거리라면 
플로이드와샬은 그래프에서 모든 정점 사이의 최단거리를 구하는 것이 가능하다. 
그래프의 간선들 중 음의 가중치가 존재해도 실행된다. 
시간 복잡도는 3중 for문으로 인한 O(V^3)을 가진다. 많은 시간이 소요되지만 
이 알고리즘을 이용해야하는 상황이 존재한다.

플로이드 와샬의 기본 개념은 i에서 출발해 j로 가는 경로의 가중치를 저장하는 2차원 배열을 채우는데, 
i를 출발해 j로 바로 가는 것보다 k를 거쳐 j로 가는 게 효율적일 경우(저렴할 경우) 해당 값을 갱신해준다. 
k의 값을 가장 바깥 for문에서 반복해주므로 하나의 경유지 k만 거치는 것뿐만 아니라 
여러 경유지를 거치는 경로또한 포함한다.


# k : 경유지
for k in range(1, v+1):
    # i : 출발지    
    for i in range(1, v+1):
        # j : 목적지
        for j in range(1, v+1):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]) # 직접 가기 or k를 거쳐가기
'''